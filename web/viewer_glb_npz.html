<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>UniRig GLB + NPZ Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #2a2a2a;
            font-family: monospace;
            width: 100%;
            height: 100vh;
        }
        #viewerContainer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            text-align: center;
            z-index: 10;
        }
        #controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(26, 26, 26, 0.95);
            border-top: 1px solid #444;
            padding: 10px;
            color: white;
            font-size: 11px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }
        #controls button {
            background: #4a4a4a;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
        }
        #controls button:hover {
            background: #5a5a5a;
        }
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        #status {
            color: #888;
            font-size: 11px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="viewerContainer">
        <canvas id="canvas"></canvas>
        <div id="loading">Ready to load GLB + skeleton</div>
    </div>

    <div id="controls">
        <div><strong>UniRig GLB + NPZ Viewer</strong></div>

        <div class="control-group">
            <label class="checkbox-label">
                <input type="checkbox" id="showSkeleton" checked>
                <span>Show Skeleton</span>
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="showMesh" checked>
                <span>Show Mesh</span>
            </label>
            <label class="checkbox-label">
                <input type="checkbox" id="showBounds">
                <span>Show Bounds</span>
            </label>
        </div>

        <div class="control-group">
            <button id="resetCamera">Reset Camera</button>
        </div>

        <div id="status">No mesh loaded</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "/extensions/ComfyUI-UniRig/static/three/three.module.js",
            "three/addons/": "/extensions/ComfyUI-UniRig/static/three/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        console.log('[UniRig GLB+NPZ Viewer] Initializing...');

        const canvas = document.getElementById('canvas');
        const loading = document.getElementById('loading');
        const statusEl = document.getElementById('status');

        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);

        // Camera
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 2, 2);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Controls
        const controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.zoomSpeed = 3.0;
        controls.minDistance = 0.1;
        controls.zoomToCursor = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight1.position.set(5, 10, 7);
        scene.add(dirLight1);

        const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        dirLight2.position.set(-5, -5, -7);
        scene.add(dirLight2);

        // Grid
        let grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        scene.add(grid);

        // Axes
        let axes = new THREE.AxesHelper(1);
        scene.add(axes);

        // State
        let currentMesh = null;
        let boneGizmos = [];
        let boneLines = [];
        let meshBoundingBox = null;
        let skeletonBoundingBox = null;
        let defaultCameraPosition = new THREE.Vector3(2, 2, 2);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Create bounding boxes
        function createBoundingBoxes(meshBox, skeletonBox) {
            // Clear existing
            if (meshBoundingBox) {
                scene.remove(meshBoundingBox);
                meshBoundingBox = null;
            }
            if (skeletonBoundingBox) {
                scene.remove(skeletonBoundingBox);
                skeletonBoundingBox = null;
            }

            if (meshBox && !meshBox.isEmpty()) {
                meshBoundingBox = new THREE.Box3Helper(meshBox, 0x00ff00);
                meshBoundingBox.visible = document.getElementById('showBounds').checked;
                scene.add(meshBoundingBox);
                console.log('[UniRig GLB+NPZ Viewer] Mesh bounds:', meshBox.min, meshBox.max);
            }

            if (skeletonBox && !skeletonBox.isEmpty()) {
                skeletonBoundingBox = new THREE.Box3Helper(skeletonBox, 0x00ffff);
                skeletonBoundingBox.visible = document.getElementById('showBounds').checked;
                scene.add(skeletonBoundingBox);
                console.log('[UniRig GLB+NPZ Viewer] Skeleton bounds:', skeletonBox.min, skeletonBox.max);
            }
        }

        // Create skeleton visualization
        function createSkeletonVis(skeletonData) {
            console.log('[UniRig GLB+NPZ Viewer] Creating skeleton visualization');

            // Clear existing
            boneGizmos.forEach(gizmo => scene.remove(gizmo));
            boneGizmos = [];
            boneLines.forEach(line => scene.remove(line));
            boneLines = [];

            const joints = skeletonData.joints;
            const parents = skeletonData.parents;
            const names = skeletonData.names;

            if (!joints || joints.length === 0) {
                console.warn('[UniRig GLB+NPZ Viewer] No joints in skeleton data');
                return null;
            }

            console.log(`[UniRig GLB+NPZ Viewer] ${joints.length} joints found`);

            // Calculate gizmo size from mesh bounds
            const skeletonBox = new THREE.Box3();
            joints.forEach(joint => {
                skeletonBox.expandByPoint(new THREE.Vector3(joint[0], joint[1], joint[2]));
            });

            const size = skeletonBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const gizmoSize = maxDim * 0.02;

            // Create bone gizmos (spheres at joints)
            joints.forEach((joint, i) => {
                const geometry = new THREE.SphereGeometry(gizmoSize, 16, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.9
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(joint[0], joint[1], joint[2]);
                sphere.userData.boneName = names ? names[i] : `Bone_${i}`;
                scene.add(sphere);
                boneGizmos.push(sphere);
            });

            // Create bone lines (parent-child connections)
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffaa,
                linewidth: 2,
                transparent: true,
                opacity: 0.7
            });

            joints.forEach((joint, i) => {
                const parentIdx = parents[i];
                if (parentIdx !== null && parentIdx >= 0 && parentIdx < joints.length) {
                    const parentJoint = joints[parentIdx];
                    const points = [
                        new THREE.Vector3(parentJoint[0], parentJoint[1], parentJoint[2]),
                        new THREE.Vector3(joint[0], joint[1], joint[2])
                    ];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial.clone());
                    scene.add(line);
                    boneLines.push(line);
                }
            });

            console.log(`[UniRig GLB+NPZ Viewer] Created ${boneGizmos.length} gizmos, ${boneLines.length} bone lines`);
            return skeletonBox;
        }

        // Load GLB + skeleton
        function loadGLBAndSkeleton(glbPath, skeletonData) {
            console.log('[UniRig GLB+NPZ Viewer] Loading GLB:', glbPath);
            loading.textContent = 'Loading GLB mesh...';
            loading.style.display = 'block';

            // Clear previous
            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh = null;
            }

            const loader = new GLTFLoader();
            loader.load(
                glbPath,
                (gltf) => {
                    console.log('[UniRig GLB+NPZ Viewer] GLB loaded successfully');
                    currentMesh = gltf.scene;

                    // Center mesh
                    const meshBox = new THREE.Box3().setFromObject(currentMesh);
                    const center = meshBox.getCenter(new THREE.Vector3());
                    currentMesh.position.sub(center);

                    // Apply texture if available in skeleton data
                    if (skeletonData.texture_data_base64) {
                        console.log('[UniRig GLB+NPZ Viewer] Applying texture from NPZ...');
                        try {
                            // Decode base64 PNG to image
                            const img = new Image();
                            img.onload = function() {
                                console.log(`[UniRig GLB+NPZ Viewer] Texture loaded: ${img.width}x${img.height}`);

                                // Create Three.js texture
                                const texture = new THREE.Texture(img);
                                texture.needsUpdate = true;
                                texture.colorSpace = THREE.SRGBColorSpace;

                                // Apply texture to all meshes
                                currentMesh.traverse((child) => {
                                    if (child.isMesh) {
                                        console.log('[UniRig GLB+NPZ Viewer] Applying texture to mesh:', child.name);

                                        // Create new material with texture
                                        child.material = new THREE.MeshStandardMaterial({
                                            map: texture,
                                            side: THREE.DoubleSide
                                        });

                                        // Apply UV coordinates if provided
                                        if (skeletonData.uv_coords && skeletonData.uv_faces) {
                                            console.log('[UniRig GLB+NPZ Viewer] Applying UV coordinates from NPZ');
                                            const uvArray = new Float32Array(child.geometry.attributes.position.count * 2);

                                            // Map face-corner UVs to vertex UVs
                                            // NOTE: This is simplified - assumes faces match the geometry's face order
                                            for (let i = 0; i < skeletonData.uv_faces.length; i++) {
                                                const uvFace = skeletonData.uv_faces[i];
                                                for (let j = 0; j < uvFace.length && j < 3; j++) {
                                                    const uvIdx = uvFace[j];
                                                    const uv = skeletonData.uv_coords[uvIdx];
                                                    const vertexIdx = i * 3 + j;
                                                    if (vertexIdx * 2 + 1 < uvArray.length) {
                                                        uvArray[vertexIdx * 2] = uv[0];
                                                        uvArray[vertexIdx * 2 + 1] = uv[1];
                                                    }
                                                }
                                            }

                                            child.geometry.setAttribute('uv', new THREE.BufferAttribute(uvArray, 2));
                                        }
                                    }
                                });
                            };
                            img.onerror = function() {
                                console.error('[UniRig GLB+NPZ Viewer] Failed to load texture image');
                            };
                            img.src = 'data:image/png;base64,' + skeletonData.texture_data_base64;
                        } catch (error) {
                            console.error('[UniRig GLB+NPZ Viewer] Error applying texture:', error);
                        }
                    }

                    scene.add(currentMesh);

                    // Create skeleton visualization
                    const skeletonBox = createSkeletonVis(skeletonData);

                    // Create bounding boxes
                    createBoundingBoxes(meshBox, skeletonBox);

                    // Adjust camera
                    const size = meshBox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const distance = maxDim * 2.5;

                    // Update grid/axes
                    scene.remove(grid);
                    scene.remove(axes);
                    const gridSize = Math.max(10, Math.ceil(maxDim * 1.5));
                    grid = new THREE.GridHelper(gridSize, Math.max(10, Math.ceil(gridSize / 10)), 0x444444, 0x222222);
                    scene.add(grid);
                    axes = new THREE.AxesHelper(maxDim * 0.3);
                    scene.add(axes);

                    defaultCameraPosition.set(distance, distance, distance);
                    camera.position.copy(defaultCameraPosition);
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                    controls.update();

                    loading.style.display = 'none';
                    statusEl.textContent = `Loaded: ${skeletonData.joints.length} joints`;
                    console.log('[UniRig GLB+NPZ Viewer] Ready');
                },
                (progress) => {
                    if (progress.lengthComputable) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(0);
                        loading.textContent = `Loading... ${percent}%`;
                    }
                },
                (error) => {
                    console.error('[UniRig GLB+NPZ Viewer] Error loading GLB:', error);
                    loading.textContent = 'Error loading GLB - check console';
                    loading.style.color = '#ff6666';
                }
            );
        }

        // Reset camera
        function resetCamera() {
            camera.position.copy(defaultCameraPosition);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        // UI Controls
        document.getElementById('showSkeleton').addEventListener('change', (e) => {
            boneGizmos.forEach(gizmo => gizmo.visible = e.target.checked);
            boneLines.forEach(line => line.visible = e.target.checked);
        });

        document.getElementById('showMesh').addEventListener('change', (e) => {
            if (currentMesh) {
                currentMesh.visible = e.target.checked;
            }
        });

        document.getElementById('showBounds').addEventListener('change', (e) => {
            if (meshBoundingBox) meshBoundingBox.visible = e.target.checked;
            if (skeletonBoundingBox) skeletonBoundingBox.visible = e.target.checked;
        });

        document.getElementById('resetCamera').addEventListener('click', resetCamera);

        // Listen for messages from parent
        window.addEventListener('message', (event) => {
            console.log('[UniRig GLB+NPZ Viewer] Received message:', event.data);

            if (event.data.type === 'LOAD_GLB_AND_SKELETON') {
                loadGLBAndSkeleton(event.data.glbPath, event.data.skeletonData);
            }
        });

        // Notify parent that viewer is ready
        console.log('[UniRig GLB+NPZ Viewer] Ready');
        if (window.parent) {
            window.parent.postMessage({ type: 'VIEWER_READY' }, '*');
        }
    </script>
</body>
</html>
